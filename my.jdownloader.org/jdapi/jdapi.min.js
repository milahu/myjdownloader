define("coreCrypto", [], function () {
  CryptoJS.lib.WordArray.firstHalf = function () {
    this._firstHalf ||= new CryptoJS.lib.WordArray.init(this.words.slice(0, this.words.length / 2));
    return this._firstHalf;
  };
  CryptoJS.lib.WordArray.secondHalf = function () {
    this._secondHalf ||= new CryptoJS.lib.WordArray.init(this.words.slice(this.words.length / 2, this.words.length));
    return this._secondHalf;
  };
  return CryptoJS;
});
define("coreCryptoUtils", ["coreCrypto"], function (a) {
  return {
    hashPassword: function (b, c, d) {
      return a.SHA256(a.enc.Utf8.parse(b.toLowerCase() + c + d.toLowerCase()));
    },
    processPassword: function (a) {
      if (!a.email || !a.pass) {
        throw "processPassword requires set options.email and options.pass";
      }
      a.loginSecret = this.hashPassword(a.email, a.pass, "server");
      a.deviceSecret = this.hashPassword(a.email, a.pass, "device");
      delete a.pass;
    },
    initialiseConnection: function (b, c, d) {
      if (!b.loginSecret && !b.serverEncryptionToken) {
        throw "either loginSecret or serverEncryptionToken must be set, probably should call processPassword(options) first";
      }
      if (!b.deviceSecret) {
        throw "deviceSecret not set";
      }
      if (!c || !d) {
        throw "sessiontoken and regaintoken are required to initialise connection";
      }
      b.sessiontoken = c;
      b.regaintoken = d;
      var e = a.enc.Hex.parse(b.sessiontoken);
      if (b.loginSecret) {
        var f = b.loginSecret.concat(e);
        b.serverEncryptionTokenOld = b.serverEncryptionToken;
        b.serverEncryptionToken = a.SHA256(f);
        delete b.loginSecret;
      } else {
        b.serverEncryptionTokenOld = b.serverEncryptionToken;
        var f = b.serverEncryptionToken.concat(e);
        b.serverEncryptionToken = a.SHA256(f);
      }
      var g = b.deviceSecret.clone();
      var h = g.concat(e);
      b.deviceEncryptionTokenOld = b.deviceEncryptionToken;
      b.deviceEncryptionToken = a.SHA256(h);
    },
    encryptJSON: function (b, c, d) {
      if (!b) {
        var e = {
          data: c
        };
        return e;
      }
      var f;
      var g;
      if (d) {
        var h = 32;
        var i = window.crypto || window.msCrypto;
        if (Uint8Array && i && i.getRandomValues) {
          try {
            f = new Uint8Array(16);
            g = new Uint8Array(h);
            i.getRandomValues(f);
            i.getRandomValues(g);
            var j = this.ua2hex(f);
            var k = this.ua2hex(g);
            f = CryptoJS.enc.Hex.parse(j);
            g = CryptoJS.enc.Hex.parse(k);
          } catch (a) {}
        }
        if (!f || !g) {
          f = a.lib.WordArray.random(16);
          g = a.lib.WordArray.random(h);
        }
      } else {
        f = b.firstHalf();
        g = b.secondHalf();
      }
      var l = a.AES.encrypt(JSON.stringify(c), g, {
        mode: a.mode.CBC,
        iv: f
      });
      var e = {};
      if (d) {
        var m = new JSEncrypt();
        m.setPublicKey(d);
        var n = CryptoJS.enc.Hex.stringify(f);
        var o = CryptoJS.enc.Hex.stringify(g);
        var p = m.encrypt(n + o);
        e.rsa = p;
        e.contentType = "application/rsajson; charset=utf-8";
        e.iv = f;
        e.key = g;
        e.data = p + "|" + l.toString();
      } else {
        e.contentType = "application/aesjson; charset=utf-8";
        e.iv = b.firstHalf();
        e.key = b.secondHalf();
        e.data = l.toString();
      }
      return e;
    },
    ua2hex: function (a) {
      var b = "";
      for (var c = 0; c < a.length; c++) {
        var d = a[c].toString(16);
        if (d.length < 2) {
          d = "0" + d;
        }
        b += d;
      }
      return b;
    },
    decryptJSON: function (b, c, d) {
      try {
        var e = null;
        var f = a.AES.decrypt(d, c, {
          mode: a.mode.CBC,
          iv: b
        }).toString(a.enc.Utf8);
        if (f && typeof f == "string") {
          e = JSON.parse(f);
        }
        return e;
      } catch (a) {
        return d;
      }
    },
    decryptRsaJSON: function (a, b, c) {
      var d = new JSEncrypt();
      d.setPrivateKey(a + b);
      var e = d.decrypt(c);
      try {
        return this.decryptJSON(e.token.firstHalf(), e.token.secondHalf(), e.data);
      } catch (a) {
        return c;
      }
    }
  };
});
define("coreRequest", ["coreCrypto", "coreCryptoUtils"], function (a, b) {
  function c(c) {
    if (c.jdParams) {
      if (c.serverEncryptionToken !== undefined) {
        c = d(c, c.serverEncryptionToken.firstHalf(), c.serverEncryptionToken.secondHalf());
      }
      if (c.type === "GET") {
        var e = c.jdAction + "?sessiontoken=" + c.sessiontoken + "&rid=" + c.rid + "&" + $.param(c.jdParams);
      } else if (c.serverEncryptionToken) {
        c.contentType = "application/json; charset=utf-8";
        var e;
        var f;
        if (c.jdAction === "requestterminationemail") {
          e = "/my/" + c.jdAction + "?sessiontoken=" + c.sessiontoken + "&" + $.param(c.jdParams) + "&rid=" + c.rid;
        } else {
          e = c.jdAction + "?sessiontoken=" + c.sessiontoken + "&rid=" + c.rid;
          f = {
            apiVer: 1,
            params: [],
            url: e,
            rid: c.rid
          };
          if (JSON.stringify(c.jdParams) !== "{}") {
            f.params = [c.jdParams];
          }
          var g = b.encryptJSON(c.serverEncryptionToken, f);
          g.contentType = "application/json; charset=UTF-8";
          c.data = g.data;
          c.contentType = g.contentType;
          c = d(c, g.iv, g.key);
          e += "&signature=" + a.HmacSHA256(a.enc.Utf8.parse(e), c.serverEncryptionToken).toString(c.TRANSFER_ENCODING);
        }
        c.url = c.API_ROOT + e;
      } else {
        logger.error("[MYJD] [JSAPI] [REQUEST] [FAILED] Server encryption token missing. Action: " + JSON.stringify(c ? c.jdAction : "NO_ACTION"));
      }
    } else if (c.deviceEncryptionToken) {
      var g = b.encryptJSON(c.deviceEncryptionToken, c.jdData, c.rsaPublicKey);
      c.contentType = g.contentType;
      c.data = g.data;
      c = d(c, g.iv, g.key);
      c.url = c.API_ROOT + "/t_" + c.sessiontoken + "_" + c.deviceId + c.jdAction;
    } else {
      logger.error("[MYJD] [JSAPI] [REQUEST] [FAILED] " + JSON.stringify(c ? c.type : "NO_OPTIONS") + " Error: Device encryption token missing!");
    }
  }
  function d(a, c, d) {
    a.converters = {
      "* aesjson-server": b.decryptJSON.bind(this, c, d),
      "* aesjson": b.decryptJSON.bind(this, c, d)
    };
    return a;
  }
  function e(a) {
    c(a);
    this.options = a;
  }
  $.extend(e.prototype, {
    send: function () {
      var a;
      var b = $.Deferred();
      var c = this.options;
      c.beforeSend = function () {
        a = Date.now();
      };
      var d = $.ajax(this.options);
      d.done(function (d) {
        logger.log("[MYJD] [JSAPI] [REQUEST] " + JSON.stringify(c ? c.type : "NO_TYPE") + " " + JSON.stringify(c ? c.url : "NO_URL") + "\nOPTIONS:\n" + JSON.stringify(c || "NO_OPTIONS") + "\n\nRESPONSE:\n" + JSON.stringify(d));
        d.requestDuration = Date.now() - a;
        b.resolve(d);
      });
      d.fail(function (d) {
        d.requestDuration = Date.now() - a;
        try {
          if (d.responseText !== undefined) {
            b.reject(JSON.parse(d.responseText));
          } else if (d.statusText !== undefined) {
            if (d.statusText === "error") {
              b.reject({
                type: "CONNECTION_REFUSED"
              });
            } else if (d.statusText === "timeout") {
              b.reject({
                type: "TIMEOUT"
              });
            } else {
              b.reject({
                type: "UNKNOWN_ERROR"
              });
            }
          } else {
            b.reject({
              type: "UNKNOWN_ERROR"
            });
          }
        } catch (a) {
          b.reject({
            type: "UNKNOWN_ERROR"
          });
        }
        logger.error("[MYJD] [JSAPI] [REQUEST] [FAILED] " + JSON.stringify(c ? c.type : "NO_TYPE") + " " + JSON.stringify(c ? c.url : "NO_URL") + "\nOPTIONS:\n" + JSON.stringify(c || "NO_OPTIONS") + "\n\nRESPONSE:\n" + JSON.stringify(d));
      });
      return b;
    }
  });
  return e;
});
define("coreRequestHandler", ["coreCrypto", "coreCryptoUtils"], function (a, b) {
  var c = "jdapi/src/core/coreRequestHandler.js";
  function d(a, b, c, d) {
    this.appKey = a;
    this.transferEncoding = b;
    this.LOCAL_STORAGE_KEY = c;
    this.apiRoot = d;
  }
  $.extend(d.prototype, {
    // login to https://my.jdownloader.org/
    connect: function (c) {
      var d = $.Deferred();

      // bypass login request
      c.email = "user@example.com";
      c.pass = "some-password";

      if (c && c.email && c.pass) {
        b.processPassword(c);

        // bypass login request
        //console.log("bypassing login request"); // debug
        const a = {}; // response from api.jdownloader.org/my/connect
        a.rid = "?";
        a.sessiontoken = "?";
        a.regaintoken = "?";
        b.initialiseConnection(c, a.sessiontoken, a.regaintoken);
        dataStore.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify(c)).then(function () {
          d.resolve(c);
        });
        return d;

        b.processPassword(c);
        var e;
        var f = {
          email: c.email
        };
        e = "/my/connect";
        f.appkey = this.appKey;
        f.rid = 0;
        var g = e + "?" + $.param(f);
        g += "&signature=" + a.HmacSHA256(a.enc.Utf8.parse(g), c.loginSecret).toString(this.transferEncoding);
        var h = $.ajax({
          url: this.apiRoot + g,
          //url: "https://api.jdownloader.org" + g, // debug: send request to api.jdownloader.org/my/connect
          type: "POST",
          async: true,
          dataType: "aesjson-server",
          converters: {
            "* aesjson-server": b.decryptJSON.bind(this, c.loginSecret.firstHalf(), c.loginSecret.secondHalf())
          }
        });
        h.fail(d.reject);
        d.fail(h.abort);
        h.done(function (a) {
          console.log("response from api.jdownloader.org/my/connect", a); // debug
          if (a.rid !== f.rid) {
            return d.reject(undefined, "replay attack");
          }
          b.initialiseConnection(c, a.sessiontoken, a.regaintoken);
          dataStore.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify(c)).then(function () {
            d.resolve(c);
          });
        }.bind(this));
      } else {
        var i = this.LOCAL_STORAGE_KEY;
        dataStore.getItem(i).then(function (b) {
          var e;
          try {
            e = JSON.parse(b[i]);
            if (e) {
              c = $.extend({}, e);
              if (e.serverEncryptionToken) {
                c.serverEncryptionToken = a.lib.WordArray.random(e.serverEncryptionToken.sigBytes);
                c.serverEncryptionToken.words = e.serverEncryptionToken.words;
              }
              if (e.deviceEncryptionToken) {
                c.deviceEncryptionToken = a.lib.WordArray.random(e.deviceEncryptionToken.sigBytes);
                c.deviceEncryptionToken.words = e.deviceEncryptionToken.words;
              }
              if (e.deviceSecret) {
                c.deviceSecret = a.lib.WordArray.random(e.deviceSecret.sigBytes);
                c.deviceSecret.words = e.deviceSecret.words;
              }
              d.resolve(c);
            } else {
              d.reject();
            }
          } catch (a) {
            d.reject();
          }
        });
      }
      return d;
    },
    reconnect: function (d, e) {
      var g;
      var h = $.Deferred();
      var i = this;
      dataStore.getItem(c).then(function (j) {
        try {
          g = JSON.parse(j[c]);
        } catch (a) {}
        if (g && new Date().getTime() - g.time < 5000) {
          window.addEventListener("storage", function (a) {
            if (a.key === this.LOCAL_STORAGE_KEY) {
              if (f.newValue) {
                h.resolve();
              } else {
                h.reject();
              }
            }
          }, false);
        } else {
          dataStore.setItem(c, JSON.stringify({
            time: new Date().getTime()
          })).then(function () {
            var f;
            var g = {};
            f = "/my/reconnect";
            g.appkey = i.appKey;
            g.sessiontoken = d.sessiontoken;
            g.regainToken = d.regaintoken;
            g.rid = e;
            var j = f + "?" + $.param(g);
            j += "&signature=" + a.HmacSHA256(a.enc.Utf8.parse(j), d.serverEncryptionToken).toString(this.transferEncoding);
            var k = $.ajax({
              url: d.API_ROOT + j,
              type: "POST",
              async: true,
              dataType: "aesjson-server",
              converters: {
                "* aesjson-server": b.decryptJSON.bind(this, d.serverEncryptionToken.firstHalf(), d.serverEncryptionToken.secondHalf())
              }
            });
            k.fail(h.reject.bind(h));
            h.fail(k.abort.bind(k));
            k.done(function (a) {
              b.initialiseConnection(d, a.sessiontoken, a.regaintoken);
              dataStore.removeItem(c);
              dataStore.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify(d)).then(h.resolve);
            }.bind(i));
          });
        }
      });
      return h;
    },
    disconnect: function (c) {
      var d = {
        rid: c.rid,
        sessiontoken: c.sessiontoken
      };
      var e = "/my/disconnect?" + $.param(d);
      e += "&signature=" + a.HmacSHA256(a.enc.Utf8.parse(e), c.serverEncryptionToken).toString(this.transferEncoding);
      return $.ajax({
        url: this.apiRoot + e,
        async: true,
        type: "POST",
        dataType: "aesjson-server",
        converters: {
          "* aesjson-server": b.decryptJSON.bind(this, c.serverEncryptionToken.firstHalf(), c.serverEncryptionToken.secondHalf())
        }
      }).done(function (a) {
        if (a.rid !== c.rid) {
          return this.connection.reject(undefined, "replay attack");
        }
      }.bind(this));
    }
  });
  return d;
});
define("coreCore", ["coreCrypto", "coreCryptoUtils", "coreRequest", "coreRequestHandler"], function (a, b, c, d) {
  "use strict";

  var e;
  var f = a.enc.Hex;
  if (!window || !window.location || !window.location.protocol) {
    throw new Error("MyJDownloader JS API: Failed to initialize API Root");
  }
  if (window.location.protocol === "https:" || window.location.protocol === "http:") {
    e = window.location.protocol + "//" + window.location.host;
  } else {
    if (window.location.protocol !== "chrome-extension:" && window.location.protocol !== "moz-extension:") {
      throw new Error("MyJDownloader JS API: Unknown host protocol " + window.location.protocol);
    }
    e = "https://" + window.location.host;
  }
  var g = "jdapi/src/core/core.js";
  var h = 0;
  var i = 1;
  var j = 3;
  var k = function () {
    var a = i;
    var b = new Array();
    return {
      setAPIState: function (c) {
        a = c;
        b.forEach(function (b) {
          try {
            b(a);
          } catch (a) {}
        });
      },
      getAPIState: function () {
        return a;
      },
      addAPIStateChangeListener: function (a) {
        if (!a || typeof a != "function") {
          throw new TypeError("APIStateChangeListener must be of type function");
        }
        if (b.indexOf(a) === -1) {
          b.push(a);
        }
      }
    };
  }();
  var l = "myjd_webinterface_1_0_1";
  var m = new Array();
  var n = new d(l, f, g, e);
  var o = 0;
  function p() {
    var a = new Date().getTime();
    if (o === a) {
      a++;
    }
    o = a;
    return a;
  }
  function q(a, b, c) {
    if (c) {
      l = c;
    }
    k.setAPIState(i);
    a = a || {};
    this.options = a;
    this.TRANSFER_ENCODING = f;
    if (b && $.isFunction(b.promise)) {
      this.connect(this.options).then(function () {
        setTimeout(function () {
          b.resolve();
        }, 0);
      }, function () {
        setTimeout(function () {
          b.reject();
        }, 0);
      });
    } else if (b && $.isFunction(b)) {
      this.connect(this.options).done(function () {
        setTimeout(function () {
          b();
        }, 0);
      });
    } else {
      this.connect(this.options);
    }
    window.addEventListener("storage", function (a) {
      if (a.key === g) {
        if (a.newValue) {
          this.connect();
        } else {
          this.disconnect();
        }
      }
    }.bind(this), false);
  }
  $.extend(q.prototype, {
    requestCount: 0,
    connect: function (a) {
      k.setAPIState(i);
      var b = $.Deferred();
      var c = n.connect(a);
      c.done(function (a) {
        a.API_ROOT = e;
        this.options = a;
        k.setAPIState(h);
        this._handleEnqueuedRequestsAndSetConnected();
        b.resolve(a);
      }.bind(this));
      c.fail(function (a) {
        k.setAPIState(j);
        b.reject(a);
      }.bind(this));
      return b;
    },
    getRID: p,
    reconnect: function () {
      var a = $.Deferred();
      if (k.getAPIState() == h || k.getAPIState() == i) {
        k.setAPIState(2);
        var b = n.reconnect(this.options, p());
        b.done(function () {
          this._handleEnqueuedRequestsAndSetConnected();
        }.bind(this));
        b.fail(function () {
          this.disconnect();
        }.bind(this));
        b.then(a.resolve, a.reject);
      } else {
        a.resolve();
      }
      return a;
    },
    disconnect: function () {
      if (k.getAPIState() === j) {
        var a = $.Deferred();
        a.resolve();
        return a;
      }
      var b = n.disconnect({
        serverEncryptionToken: this.options.serverEncryptionToken,
        sessiontoken: this.options.sessiontoken,
        rid: p()
      });
      b.always(function () {
        this.options = {};
        dataStore.removeItem(g);
        k.setAPIState(j);
      }.bind(this));
      return b;
    },
    serverCall: function (a, b, c, d) {
      b = b || {};
      var g = {
        jdAction: a,
        jdParams: b,
        urlParams: c,
        type: d || "POST",
        dataType: "aesjson-server",
        serverEncryptionToken: this.options.serverEncryptionToken,
        TRANSFER_ENCODING: f,
        API_ROOT: e,
        sessiontoken: this.options.sessiontoken,
        rid: p()
      };
      return this._call(g);
    },
    deviceCall: function (a, b, c, d, g) {
      c = c || [];
      var h = p();
      var i = {
        jdAction: b,
        jdData: {
          url: b,
          params: c,
          apiVer: 1,
          rid: h
        },
        deviceId: a,
        type: "POST",
        dataType: "aesjson-server",
        deviceEncryptionToken: this.options.deviceEncryptionToken,
        TRANSFER_ENCODING: f,
        API_ROOT: e,
        sessiontoken: this.options.sessiontoken,
        rid: h
      };
      if (g) {
        i.timeout = g;
      }
      return this._call(i);
    },
    localDeviceCall: function (a, b, c, d, e, g) {
      d = d || [];
      var h = p();
      var i = {
        jdAction: c,
        jdData: {
          url: c,
          params: d,
          apiVer: 1,
          rid: h
        },
        deviceId: b,
        type: "POST",
        dataType: "aesjson-server",
        deviceEncryptionToken: this.options.deviceEncryptionToken,
        TRANSFER_ENCODING: f,
        API_ROOT: a,
        sessiontoken: this.options.sessiontoken,
        rid: h
      };
      if (g) {
        i.timeout = g;
      }
      return this._call(i);
    },
    getSessionToken: function () {
      return this.options.sessiontoken;
    },
    getSessionInfo: function () {
      return this.options;
    },
    addAPIStateChangeListener: function (a) {
      k.addAPIStateChangeListener(a);
    },
    getAPIState: function () {
      return k.getAPIState();
    },
    getAPIStatePlain: function () {
      switch (k.getAPIState()) {
        case 0:
          return "CONNECTED_STATE";
        case 1:
          return "PENDING_STATE";
        case 2:
          return "RECONNECT_STATE";
        case 3:
          return "DISCONNECTED_STATE";
        default:
          return "INVALID";
      }
    },
    getCurrentUser: function () {
      return {
        loggedIn: this.getAPIState() !== 3,
        name: this.options.email
      };
    },
    API_ROOT: e,
    APP_KEY: l,
    _rebuildRequestOptions: function (a) {
      if (a.deviceEncryptionToken) {
        a.deviceEncryptionToken = this.options.deviceEncryptionToken;
        a.deviceEncryptionTokenOld = this.options.deviceEncryptionTokenOld;
      }
      a.serverEncryptionToken &&= this.options.serverEncryptionToken;
      a.sessiontoken = this.options.sessiontoken;
      a.rid = p();
      return a;
    },
    _handleEnqueuedRequestsAndSetConnected: function () {
      for (k.setAPIState(h); m.length > 0;) {
        var a = m.shift();
        var b = this._rebuildRequestOptions(a.options);
        setTimeout(function () {
          var c = this._call(b, 1);
          c.done(a.deferred.resolve);
          c.fail(a.deferred.reject);
        }.bind(this), 10);
      }
    },
    _call: function (a, b) {
      b = b || 0;
      var d = $.Deferred();
      if (k.getAPIState() === h) {
        var e = new c(a).send();
        e.done(d.resolve);
        e.fail(function (c) {
          if (c.type && c.type === "TOKEN_INVALID" && b === 0) {
            m.push({
              deferred: d,
              options: a
            });
            this.reconnect();
          } else if (c.type && c.type === "AUTH_FAILED") {
            d.reject(c);
            this.disconnect();
          } else {
            d.reject(c);
          }
        }.bind(this));
      } else {
        m.push({
          deferred: d,
          options: a
        });
      }
      return d;
    }
  });
  return q;
});
define("device", [], function () {
  function a(a, b) {
    this.jdAPICore = a;
    this.state = "OFFLINE";
    this.deviceId = b.id;
    this.rsaPublicKey = b.rsaPublicKey;
    this.deviceName = b.name;
  }
  $.extend(a.prototype, {
    call: function (a, b, c) {
      if (this.localURL) {
        if (c) {
          c(true);
        }
        return this.jdAPICore.localDeviceCall(this.localURL, this.deviceId, a, b, this.rsaPublicKey);
      } else {
        if (c) {
          c(false);
        }
        return this.jdAPICore.deviceCall(this.deviceId, a, b, this.rsaPublicKey);
      }
    },
    setLocalURL: function (a) {
      this.localURL = a;
    },
    setPublicKey: function (a) {
      this.publicKey = a;
    },
    getURL: function () {
      if (this.localURL) {
        return this.localURL;
      } else {
        return this.jdAPICore.API_ROOT;
      }
    },
    isInLocalMode: function () {
      return !!this.localURL;
    }
  });
  return a;
});
define("serverServer", ["coreCrypto", "coreCryptoUtils"], function (a, b) {
  function c(a) {
    this.jdapiCore = a;
  }
  $.extend(c.prototype, {
    listDevices: function () {
      return this.jdapiCore.serverCall("/my/listdevices");
    },
    getCaptcha: function () {
      return $.ajax({
        url: this.jdapiCore.API_ROOT + "/captcha/getCaptcha",
        type: "post",
        dataType: "json"
      });
    },
    registerUser: function (a) {
      a.referrer = "webui";
      var b = this.jdapiCore.API_ROOT + "/my/requestregistrationemail?email=" + encodeURIComponent(a.email) + "&captchaResponse=" + encodeURIComponent(a.captchaResponse) + "&captchaChallenge=" + encodeURIComponent(a.captchaChallenge) + "&referer=" + encodeURIComponent(a.referrer);
      return $.ajax({
        url: b,
        type: "POST",
        dataType: "text"
      });
    },
    confirmEmail: function (c, d, e) {
      if (!e) {
        throw "No credentials given";
      }
      var f = "/my/finishregistration";
      var g = b.hashPassword(c, e, "server");
      var h = a.enc.Hex.parse(d);
      var i = h.firstHalf();
      var j = h.secondHalf();
      var k = a.AES.encrypt(g, j, {
        mode: a.mode.CBC,
        iv: i
      });
      var l = a.enc.Hex.stringify(k.ciphertext);
      var m = f + "?email=" + encodeURIComponent(c) + "&loginSecret=" + encodeURIComponent(l);
      m += "&signature=" + encodeURIComponent(a.HmacSHA256(a.enc.Utf8.parse(m), h).toString(this.jdapiCore.TRANSFER_ENCODING));
      return $.ajax({
        url: this.jdapiCore.API_ROOT + m,
        type: "POST",
        dataType: "text"
      });
    },
    requestPasswordChangeEmail: function (a, b, c) {
      var d = {};
      var e = "/my/requestpasswordresetemail";
      d.email = a;
      d.captchaResponse = c;
      d.captchaChallenge = b;
      var f = e + "?" + $.param(d);
      return $.ajax({
        url: this.jdapiCore.API_ROOT + f,
        type: "POST",
        dataType: "text"
      });
    },
    requestTerminationEmail: function (a, b) {
      return this.jdapiCore.serverCall("/my/requestterminationemail", {
        captchaResponse: b,
        captchaChallenge: a
      });
    },
    finishTermination: function (c, d, e, f, g) {
      var h = {
        email: c,
        pass: d
      };
      b.processPassword(h);
      var i = "/my/finishtermination";
      var j = a.enc.Hex.parse(e);
      var k = j.firstHalf();
      var l = j.secondHalf();
      var m = a.AES.encrypt(h.loginSecret, l, {
        mode: a.mode.CBC,
        iv: k
      });
      var n = a.enc.Hex.stringify(m.ciphertext);
      var o = i + "?email=" + encodeURIComponent(c) + "&loginSecret=" + encodeURIComponent(n) + "&captchaResponse=" + encodeURIComponent(g) + "&captchaChallenge=" + encodeURIComponent(f);
      o += "&signature=" + encodeURIComponent(a.HmacSHA256(a.enc.Utf8.parse(o), j).toString(this.jdapiCore.transferEncoding));
      return $.ajax({
        url: this.jdapiCore.API_ROOT + o,
        type: "POST",
        dataType: "text"
      });
    },
    changePassword: function (c, d, e) {
      var f = "/my/finishpasswordreset";
      var g = b.hashPassword(c, d, "server");
      var h = a.enc.Hex.parse(e);
      var i = h.firstHalf();
      var e = h.secondHalf();
      var j = a.AES.encrypt(g, e, {
        mode: a.mode.CBC,
        iv: i
      });
      var k = a.enc.Hex.stringify(j.ciphertext);
      var l = f + "?email=" + encodeURIComponent(c) + "&loginSecret=" + encodeURIComponent(k);
      l += "&signature=" + encodeURIComponent(a.HmacSHA256(a.enc.Utf8.parse(l), h).toString(this.jdapiCore.TRANSFER_ENCODING));
      return $.ajax({
        url: this.jdapiCore.API_ROOT + l,
        type: "POST",
        dataType: "text"
      });
    },
    feedback: function (a) {
      return this.jdapiCore.serverCall("/my/feedback", a);
    },
    subscribePushNotifications: function (a, b, c) {
      return this.jdapiCore.serverCall("/notify/register", c, {
        receiverid: a,
        deviceid: b
      }, "POST");
    },
    unsubscribePushNotifications: function (a, b, c) {}
  });
  return c;
});
define("serviceService", ["coreCryptoUtils", "coreCrypto"], function (a, b) {
  function c(a) {
    this.jdapiCore = a;
  }
  $.extend(c.prototype, {
    serviceAccessTokens: {},
    requestAccessToken: function (a) {
      if (this.serviceAccessTokens[a]) {
        var b = $.Deferred();
        b.resolve(this.serviceAccessTokens[a]);
        return b;
      }
      this.serviceAccessTokens[a] = {};
      var c = this.serviceAccessTokens[a];
      if (c.requestOnTheWay) {
        var d = $.Deferred();
        c.deferredQueue = c.deferredQueue || new Array();
        c.deferredQueue.push(d);
        return d;
      }
      c.requestOnTheWay = true;
      var e = {};
      var f = "";
      f = "/my/requestaccesstoken";
      e.service = a;
      var g = this.jdapiCore.serverCall(f, e);
      g.done(function (a) {
        $.extend(c, a);
      });
      return g;
    },
    send: function (a, c, d, e) {
      var f = $.Deferred();
      var g = this;
      this.requestAccessToken(a).done(function (h) {
        var i = d + "?" + e + "&rid=12&accesstoken=" + h.accessToken;
        i = encodeURI(i);
        i += "&signature=" + b.HmacSHA256(b.enc.Utf8.parse(i), b.enc.Hex.parse(h.accessSecret)).toString(b.enc.Hex);
        $.ajax({
          url: c + i,
          type: "GET"
        }).done(function (b) {
          if (g.serviceAccessTokens[a]) {
            g.serviceAccessTokens[a].used++;
          }
          f.resolve(b);
        }).fail(function (b) {
          if (g.serviceAccessTokens[a] && g.serviceAccessTokens[a].count > 0) {
            delete g.serviceAccessTokens[a];
            g.sendServiceRequest(a, c, d, e).then(f.resolve, f.reject);
          } else {
            delete g.serviceAccessTokens[a];
            f.reject(b);
          }
        });
      }).fail(function (a) {
        f.reject(a);
      });
      return f;
    }
  });
  return c;
});
define("deviceController", ["device"], function (a) {
  var b = 5000;
  var c = 5000;
  function d(a) {
    this.index = 0;
    this.items = a || [];
  }
  $.extend(d.prototype, {
    first: function () {
      this.reset();
      return this.next();
    },
    next: function () {
      return this.items[this.index++];
    },
    hasNext: function () {
      return this.index < this.items.length;
    },
    reset: function () {
      this.index = 0;
    },
    each: function (a) {
      for (var b = this.first(); this.hasNext(); b = this.next()) {
        a(b);
      }
    }
  });
  function e(a, b) {
    this.jdAPIServer = a;
    this.jdAPICore = b;
    this.devices = {};
  }
  $.extend(e.prototype, {
    refreshAllDeviceAPIs: function () {

      // bypass request to /my/listdevices
      var c = {
          "id": "3eaaf4117721d426cc8e93d7b106030b",
          "type": "jd",
          "name": "JDownloader", // example: JDownloader@Docker
          "status": "UNKNOWN"
      }
      var e = this;
      var f = Object.create(null);
      f[c.id] = new a(e.jdAPICore, c);
      // populate c.devices[a]
      // a = device id = "3eaaf4117721d426cc8e93d7b106030b"
      e.devices = f;
      var b = $.Deferred();
      var c = $.Deferred();
      var g = [c];
      b.resolve(g); // deviceList
      c.resolve(g); // deviceListLocalMode
      return {
        deviceList: b,
        deviceListLocalMode: c
      };

      var b = $.Deferred();
      var c = $.Deferred();
      var d = this.jdAPIServer.listDevices();
      var e = this;
      d.done(function (d) {
        var f = Object.create(null);
        var g = [];
        $.each(d.list, function (b, c) {
          f[c.id] = new a(e.jdAPICore, c);
          g.push(c);
        });
        b.resolve(g);
        e.devices = f;
        e._checkForLocalMode(d.list).done(c.resolve).fail(c.reject);
      });
      d.fail(function (a) {
        c.reject(a);
        b.reject(a);
      });
      return {
        deviceList: b,
        deviceListLocalMode: c
      };
    },
    _checkForLocalMode: function (c) {
      if (c !== undefined && c.length !== undefined && c.length != 0) {
        var d = this;
        var e = $.Deferred();
        var f = [];
        $.each(c, function (c, e) {
          d.devices[e.id] = new a(d.jdAPICore, e);
          var g = $.Deferred();
          d.jdAPICore.deviceCall(e.id, "/device/getDirectConnectionInfos", [], undefined, b).always(function (a) {
            if (a !== undefined && a.data !== undefined && a.data.infos !== undefined && a.data.infos !== null && a.data.infos.length !== 0) {
              var b = d._pingForAvailability(a.data.infos, e);
              $.when.apply(this, b).done(function () {
                g.resolve(e);
              }).fail(g.reject);
            }
          });
          f.push(g);
        });
        $.when.apply(this, f).done(function (a) {
          e.resolve(a);
        }).fail(function (a) {
          e.reject(a);
        });
        return e;
      }
      var g = $.Deferred();
      g.resolve(c);
      return g;
    },
    _pingForAvailability: function (a, b) {
      if (a !== undefined && a.length !== undefined && a.length !== 0) {
        var d;
        var e;
        var f = this;
        var g = [];
        $.each(a, function (a, h) {
          var i = $.Deferred();
          g.push(i);
          var j;
          if (window.location.protocol === undefined || window.location.protocol !== "https:" && window.location.protocol !== "http:" || window.location.protocol === "https:") {
            if (h.ip.match(/^(\d+\.\d+\.\d+\.\d+)$/) != null) {
              j = "https://" + h.ip.replace(new RegExp("\\.", "g"), "-") + ".mydns.jdownloader.org:" + h.port;
            } else if (h.ip.match(/^(\[[a-f0-9A-F:]+\])$/) != null) {
              var k = h.ip.replace(/[\[\]]/g, "");
              k = k.replace(/^:|:$/g, "");
              for (var l = k.split(":"), m = 0; m < l.length; m++) {
                var n = l[m];
                if (n != "") {
                  l[m] = ("0000" + n).substr(-4);
                } else {
                  n = [];
                  for (var o = l.length; o <= 8; o++) {
                    n.push("0000");
                  }
                  l[m] = n.join(":");
                }
              }
              j = "https://" + l.join("") + ".mydns.jdownloader.org:" + h.port;
            } else {
              j = "https://" + h.ip + ":" + h.port;
            }
          } else if (window.location.protocol && window.location.protocol === "http:") {
            j = "http://" + h.ip + ":" + h.port;
          }
          var p = f.jdAPICore.localDeviceCall(j, b.id, "/device/ping", [], undefined, c);
          p.done(function (a) {
            var c = a.requestDuration;
            if (d === undefined || c < d) {
              d = j;
              e = c;
              f.devices[b.id].setLocalURL(j);
            }
            i.resolve(f.devices[b.id]);
          });
          p.fail(function (a) {
            i.resolve(f.devices[b.id]);
          });
        });
        return g;
      }
      var h = $.Deferred();
      h.resolve();
      return h;
    },
    _iterateAndCheckForSessionPublicKey: function (b, c) {
      var d = b.next();
      if (!d) {
        c();
        return;
      }
      this.devices[d.id] = this.devices[d.id] || new a(this.jdAPICore, d);
      var e = this;
      this.jdAPICore.deviceCall(d.id, "/device/getSessionPublicKey", [], undefined).done(function (a) {
        if (a && a.data) {
          e.devices[d.id].rsaPublicKey = "-----BEGIN RSA PRIVATE KEY-----" + a.data + "-----END RSA PRIVATE KEY-----";
        } else {
          e._iterateAndCheckForSessionPublicKey(b, c);
        }
      }).fail(function () {
        e._iterateAndCheckForSessionPublicKey(b, c);
      });
    },
    getDeviceAPIForId: function (a) {
      var b = $.Deferred();
      var c = this;
      var d = $.Deferred();
      if (c.devices[a]) {
        d.resolve();
      } else {
        d = c.refreshAllDeviceAPIs().deviceList;
      }
      d.always(function () {
        b.resolve({
          call: function (b, d) {
            // called from this.apiDeviceController.getDeviceAPIForId(this.getActiveDevice()).done
            var e = $.Deferred();
            var f = c.devices[a];

            // bypass tunneling service
            f = {};
            f.call = function (a, b) {
              // a: url
              // b: data
              // based on: _call: function (a, b)
              a = window.location.protocol + "//" + window.location.host + a;
              var d = $.Deferred();
              // https://api.jquery.com/jQuery.post/
              var e = $.post(a, b);
              //e.done(d.resolve);
              e.done(res => {
                console.log("jdapi.min.js xxx.call: f.call res", res);
                d.resolve(res);
              });
              e.fail(function (c) {
                console.log("jdapi.min.js xxx.call: f.call err", c);
                if (c.type && c.type === "TOKEN_INVALID" && b === 0) {
                  // TODO m?
                  m.push({
                    deferred: d,
                    options: a
                  });
                  this.reconnect();
                } else if (c.type && c.type === "AUTH_FAILED") {
                  d.reject(c);
                  this.disconnect();
                } else {
                  d.reject(c);
                }
              }.bind(this));
              return d;
            }

            if (f) {
              f.call(b, d).then(e.resolve, e.reject, e.progress);
            } else {
              e.reject({
                responseText: {
                  type: "DEVICE_NOT_EXISTING"
                }
              });
            }
            return e;
          },
          getURL: function () {
            var b = c.devices[a];
            if (!b) {
              throw "Device with id " + a + " not found";
            }
            return b.getURL();
          },
          getTokenRoot: function () {
            var b = c.devices[a];
            if (!b) {
              throw "Device with id " + a + " not found";
            }
            return b.getURL() + "/t_" + c.jdAPICore.getSessionToken() + "_" + a;
          },
          isInLocalMode: function () {
            return c.devices[a].isInLocalMode();
          },
          deviceId: a
        });
      });
      return b;
    }
  });
  return e;
});
var dataStore;
if (typeof chrome != "undefined" && chrome && chrome.storage && chrome.storage.local) {
  var dataStore = Object.create(null);
  dataStore.setItem = function (a, b) {
    var c = $.Deferred();
    var d = Object.create(null);
    d[a] = b;
    chrome.storage.local.set(d, c.resolve);
    return c;
  };
  dataStore.getItem = function (a) {
    var b = $.Deferred();
    chrome.storage.local.get(a, function (c) {
      if (c) {
        var d = Object.create(null);
        d[a] = c[a];
        b.resolve(d);
      } else {
        b.reject();
      }
    });
    return b;
  };
  dataStore.removeItem = function (a) {
    var b = $.Deferred();
    chrome.storage.local.remove(a, b.resolve);
    return b;
  };
  dataStore.clear = function () {
    var a = $.Deferred();
    chrome.storage.local.clear(a.resolve);
    return a;
  };
} else {
  var dataStore = Object.create(null);
  dataStore.setItem = function (a, b) {
    var c = $.Deferred();
    c.resolve(window.localStorage.setItem(a, b));
    return c;
  };
  dataStore.getItem = function (a) {
    var b = $.Deferred();
    var c = Object.create(null);
    c[a] = window.localStorage.getItem(a);
    b.resolve(c);
    return b;
  };
  dataStore.removeItem = function (a) {
    var b = $.Deferred();
    b.resolve(window.localStorage.removeItem(a));
    return b;
  };
  dataStore.clearStorage = function () {
    var a = $.Deferred();
    a.resolve(window.localStorage.clear());
    return a;
  };
}
var LOGGING_ENABLED = false;
var logger = {
  log: function (a) {
    if (LOGGING_ENABLED) {
      console.log(a);
    }
  },
  warn: function (a) {
    if (LOGGING_ENABLED) {
      console.warn(a);
    }
  },
  error: function (a) {
    if (LOGGING_ENABLED) {
      console.error(a);
    }
  }
};
define("config/config", [], function () {
  return {
    TRANSFER_ENCODING: CryptoJS.enc.Hex,
    API_ROOT: "//" + window.location.host,
    LOCAL_STORAGE_KEY: "api.transport.options",
    APP_KEY: "myjd_webinterface_1_0_1"
  };
});
define("jdapi", ["coreCore", "device", "serverServer", "serviceService", "deviceController"], function (a, b, c, d, e) {
  function f(b, f, g) {
    this.jdAPICore = new a(b, f, g);
    this.apiServer = new c(this.jdAPICore);
    this.apiService = new d(this.jdAPICore);
    this.apiDeviceController = new e(this.apiServer, this.jdAPICore);
  }
  $.extend(f.prototype, {
    getCaptcha: function () {
      return this.apiServer.getCaptcha();
    },
    connect: function (a) {
      return this.jdAPICore.connect(a);
    },
    registerUser: function (a) {
      return this.apiServer.registerUser(a);
    },
    reconnect: function () {
      return this.jdAPICore.reconnect();
    },
    disconnect: function () {
      return this.jdAPICore.disconnect();
    },
    confirmEmail: function (a, b, c) {
      return this.apiServer.confirmEmail(a, b, c);
    },
    requestConfirmEmail: function (a) {
      return this.apiServer.requestConfirmEmail(a);
    },
    requestPasswordChangeEmail: function (a, b, c) {
      return this.apiServer.requestPasswordChangeEmail(a, b, c);
    },
    requestTerminationEmail: function (a, b) {
      return this.apiServer.requestTerminationEmail(a, b);
    },
    finishTermination: function (a, b, c, d, e) {
      return this.apiServer.finishTermination(a, b, c, d, e);
    },
    changePassword: function (a, b, c) {
      return this.apiServer.changePassword(a, b, c);
    },
    sendServiceRequest: function (a, b, c, d) {
      return this.apiService.send(a, b, c, d);
    },
    listDevices: function (a) {
      if (a !== undefined && a === true) {
        return this.apiDeviceController.refreshAllDeviceAPIs().deviceListLocalMode;
      } else {
        return this.apiDeviceController.refreshAllDeviceAPIs().deviceList;
      }
    },
    setActiveDevice: function (a) {
      return this.activeDeviceId = a;
    },
    getActiveDevice: function () {
      return this.activeDeviceId;
    },
    getDirectConnectionInfos: function () {
      return this.transport.getDirectConnectionInfos();
    },
    ping: function () {
      return this.transport.ping();
    },
    feedback: function (a) {
      return this.apiServer.feedback(a);
    },
    subscribePushNotifications: function (a, b, c) {
      return this.apiServer.subscribePushNotifications(a, b, c);
    },
    unsubscribePushNotifications: function (a, b, c) {},
    listen: function (a) {
      return this.send("/events/listen", [a]);
    },
    subscribe: function (a, b) {
      return this.send("/events/subscribe", [JSON.stringify(a), JSON.stringify(b)]);
    },
    unsubscribe: function (a) {
      return this.send("/events/unsubscribe", [a]);
    },
    setSubscriptionId: function (a) {
      return this.send("/events/getSubscriptionId", [a]);
    },
    getSubscriptionId: function () {
      return this.send("/events/getSubscriptionId", []);
    },
    addSubscription: function (a, b, c) {
      return this.send("/events/addSubscription", [a, b, c]);
    },
    setSubscription: function (a, b, c) {
      return this.send("/events/setsubscription", [a, JSON.stringify(b), JSON.stringify(c)]);
    },
    getSubscription: function (a) {
      return this.send("/events/getSubscription", [a]);
    },
    removeSubscription: function (a, b, c) {
      return this.send("/events/removeSubscription", [a, b, c]);
    },
    changeSubscriptionTimeouts: function (a, b, c) {
      return this.send("/events/changeSubscriptionTimeouts", [a, b, c]);
    },
    listPublisher: function () {
      return this.transport.listPublisher();
    },
    stopListen: function () {},
    send: function (a, b, c) {
      var d = $.Deferred();
      this.apiDeviceController.getDeviceAPIForId(this.getActiveDevice()).done(function (e) {
        e.call(a, b, c).then(d.resolve, d.reject, d.progress);
      });
      return d;
    },
    fetchActiveDeviceURL: function () {
      var a = $.Deferred();
      this.apiDeviceController.getDeviceAPIForId(this.getActiveDevice()).done(function (b) {
        var c = b.getURL();
        a.resolve(c);
      });
      return a;
    },
    fetchActiveDeviceTokenRoot: function () {
      var a = $.Deferred();
      this.apiDeviceController.getDeviceAPIForId(this.getActiveDevice()).done(function (b) {
        var c = b.getTokenRoot();
        a.resolve(c);
      });
      return a;
    },
    isActiveDeviceInLocalMode: function () {
      var a = $.Deferred();
      this.apiDeviceController.getDeviceAPIForId(this.getActiveDevice()).done(function (b) {
        var c = b.isInLocalMode();
        a.resolve(c);
      });
      return a;
    },
    getAuth: function () {
      return this.transport.getAuth();
    },
    addAPIStateChangeListener: function (a) {
      this.jdAPICore.addAPIStateChangeListener(a);
    },
    getAPIState: function () {
      return this.jdAPICore.getAPIState();
    },
    getAPIStatePlain: function () {
      return this.jdAPICore.getAPIStatePlain();
    },
    getCurrentUser: function () {
      return this.jdAPICore.getCurrentUser();
    },
    getCurrentSessionInfo: function () {
      var a = this.jdAPICore.getSessionInfo();
      return {
        s: a.sessiontoken,
        r: a.regaintoken,
        e: a.serverEncryptionToken.toString(CryptoJS.enc.Base64),
        d: a.deviceSecret.toString(CryptoJS.enc.Base64)
      };
    }
  });
  return f;
});
